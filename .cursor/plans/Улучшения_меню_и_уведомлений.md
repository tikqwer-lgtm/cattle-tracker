---
name: Улучшения меню и уведомлений
overview: "План изменений: уведомления (единый источник правды, read, раскрывающаяся строка, счётчик); кнопка «Добавить объект»; запрос разрешения на скачивание; ограничение размера окна и компактное меню; настройка полей в «Список всех животных»; подсказки при первом запуске; сохранение размера и позиции окна."
todos: []
isProject: false
---

# План: уведомления, кнопка «Добавить объект», обновления и главное меню

## 1. Уведомления: раскрывающаяся строка, прочитано/не прочитано, счётчик

**Текущее состояние:**

- В [electron/js/notifications.js](electron/js/notifications.js): раз в 60 с вызывается `checkUpcomingEvents()` (таймер `scheduleReminders`), при создании уведомления вызывается `showToast()` и при разрешении — системное `Notification`. То есть уведомления «выплывают» в виде тостов и системных окон.
- Центр уведомлений рендерится только на экране «Уведомления» в `renderNotificationCenter()`; нет состояния «прочитано», нет счётчика непрочитанных, нет раскрывающейся панели на главном экране.

**Что сделать:**

- Убрать автоматический показ тостов/системных уведомлений при создании уведомления по таймеру (оставить только накопление в истории). Либо оставить системные уведомления опционально в настройках, но убрать тосты по таймеру.
- **Единый источник правды:** хранить непрочитанные в том же `cattleTracker_notification_history` с полем `read`, не дублировать отдельный список — проще синхронизация и меньше багов.
- Ввести в модели уведомления поле `read: boolean` (в `cattleTracker_notification_history`). При первом сохранении помечать старые записи как прочитанные.
- При клике по уведомлению в списке помечать его как прочитанное и перерисовывать список.
- На главном экране: вместо одной кнопки «Уведомления» сделать **раскрывающуюся строку** (например, заголовок «Уведомления» + счётчик непрочитанных, по клику — разворачивается блок со списком последних N уведомлений). В свёрнутом виде показывать только строку с цифрой непрочитанных.
- В развёрнутом списке подсвечивать визуально каждое непрочитанное уведомление (например, класс `.notification-item-unread` в [electron/css/components-screens.css](electron/css/components-screens.css)).
- На кнопке/строке «Уведомления» в меню показывать бейдж с количеством непрочитанных (например, «Уведомления (3)» или маленький кружок с цифрой).

**Файлы:** [electron/js/notifications.js](electron/js/notifications.js) (модель read, загрузка/сохранение, логика «прочитано» по клику, убрать/настроить тосты при создании; новая функция рендера раскрывающейся панели на главном экране), [electron/index.html](electron/index.html) (разметка раскрывающейся строки уведомлений на экране меню), [electron/css/components-screens.css](electron/css/components-screens.css) (стили непрочитанных и бейджа). Аналогично при необходимости — веб-версия в корне (js/notifications.js, index.html, css/).

---

## 2. Кнопка «Добавить объект» не работает

**Текущее состояние:**

- Кнопка есть в [electron/index.html](electron/index.html) (`id="addObjectBtn"`). Обработчик вешается в [electron/js/menu.js](electron/js/menu.js) в `updateObjectSwitcher()`: при наличии `addBtn` задаётся `addBtn.onclick`, вызывается `addObject(name)` (из [electron/js/storage.js](electron/js/storage.js) при API или из [electron/js/storage-objects.js](electron/js/storage-objects.js) при локальном режиме).
- `updateObjectSwitcher()` вызывается при переходе на экран `menu` (navigate('menu')) и при инициализации по API в [electron/js/app.js](electron/js/app.js). В **локальном** режиме в `initApp()` вызов `updateObjectSwitcher()` не выполняется — только `loadLocally()`, `updateList()`. Первый показ меню идёт из menu.js по `DOMContentLoaded` через `navigate('menu')`, так что при первой загрузке переключатель и кнопка должны инициализироваться.

**Возможные причины:**

- Порядок загрузки: если по какой-то причине при первом `navigate('menu')` ещё не определён `addObject` (например, не поднят глобал из storage-objects), кнопка может не сработать.
- Элемент `#addObjectBtn` или `#currentObjectSelect` не найден (например, другой HTML в сборке) — тогда `updateObjectSwitcher()` выходит по `if (!select) return` и обработчик для кнопки не вешается.

**Что сделать:**

- В [electron/js/app.js](electron/js/app.js) в ветке инициализации **без API** явно вызвать `updateObjectSwitcher()` после `loadLocally()` / `updateList()`, чтобы переключатель объектов и кнопка «Добавить объект» были готовы независимо от порядка событий.
- В [electron/js/storage-objects.js](electron/js/storage-objects.js) явно выставить `window.addObject = addObject` в конце файла (дублирование экспорта), чтобы гарантировать наличие глобала до menu.js.
- Проверить в собранном Electron, что в окне загружается именно [electron/index.html](electron/index.html) с блоком `#object-switcher` и `#addObjectBtn`.

---

## 3. Перед установкой спрашивать разрешение на скачивание новой версии

**Текущее состояние:**

- В [electron/main.js](electron/main.js) в `setupAutoUpdater()`: при `update-available` сразу показывается диалог «Доступна новая версия. Скачивание в фоне…» и скачивание начинается без явного согласия пользователя. При `update-downloaded` спрашивается «Перезапустить приложение сейчас?».

**Что сделать:**

- По событию `update-available`: показывать диалог с вопросом вроде «Доступна новая версия. Разрешить скачивание?» и кнопками «Скачать», «Позже» (или «Нет»). Только при выборе «Скачать» вызывать старт загрузки (например, `autoUpdater.downloadUpdate()`), иначе не начинать скачивание.
- Текущий API electron-updater: при `update-available` обновление уже может автоматически скачиваться в зависимости от конфигурации. Нужно при необходимости отключить авто-загрузку (например, `autoUpdater.autoDownload = false`) и вызывать `downloadUpdate()` только после подтверждения пользователя.

**Файлы:** [electron/main.js](electron/main.js) (логика `update-available`, опция autoDownload, вызов downloadUpdate по согласию).

---

## 4. Ограничение размера окна и расположение кнопок главного меню

**Текущее состояние:**

- Окно создаётся в [electron/main.js](electron/main.js): начальный размер до 900×700, `minWidth`/`minHeight` 400. Нет привязки размера к экрану «меню» или «просмотр описи».
- Главное меню в [electron/index.html](electron/index.html): блок `.action-buttons` с пятью `.menu-section`, в каждой по одной кнопке (Работа с данными, Действия, Аналитика, Уведомления, Настройки). В [electron/css/components-buttons.css](electron/css/components-buttons.css) для `.action-buttons` заданы `flex-direction: column` и `gap: 20px` — кнопки выстроены вертикально и занимают много высоты.

**Что сделать:**

- Ограничить размер окна **только на экране главного меню**: при отображении экрана с `id="menu-screen"` задавать окну разумный максимум (например, maxWidth/maxHeight на основе workArea) или фиксированный «компактный» размер (например, 500×600), чтобы все элементы меню (объект, статистика, раскрывающиеся уведомления, кнопки) помещались без прокрутки там, где это возможно. При переходе на другие экраны (просмотр описи, аналитика и т.д.) снимать ограничение или не применять его (например, убрать max size или увеличить лимиты).
- Реализация: при навигации в [electron/js/menu.js](electron/js/menu.js) при `screenId === 'menu'` можно отправлять в main process сообщение (например, IPC) «установить режим компактного окна»; при переходе на экран с большим контентом (например, `view`, `analytics`) — «обычный режим». В main process в [electron/main.js](electron/main.js) по этим сообщениям вызывать `mainWindow.setMaximumSize(w, h)` или снимать ограничение. Альтернатива: задать одно «достаточное» максимальное разрешение для меню и не менять его при переходах, если приемлемо.
- Компактное расположение кнопок: изменить разметку/стили так, чтобы пять кнопок меню не шли одной колонкой. Варианты: сетка 2–3 колонки (например, `display: grid; grid-template-columns: repeat(2, 1fr)` или `repeat(3, 1fr)` для `.action-buttons` на экране меню), или одна строка с горизонтальным скроллом при нехватке места. Цель — уместить все элементы без вертикальной прокрутки при типичном размере окна.
- Случай «невозможно уместить без прокрутки»: если высота окна слишком мала (например, после ограничения max size), разрешить прокрутку контента только экрана меню (например, обёртка `#menu-screen` с `overflow-y: auto` и ограниченной высотой), не раздвигая окно. На экранах с большим контентом (просмотр описи, аналитика) окно не ограничивать по максимуму — пользователь может развернуть на весь экран.

**Файлы:** [electron/main.js](electron/main.js) (размеры окна, IPC для режима «меню»/«данные»), [electron/js/menu.js](electron/js/menu.js) (вызов IPC при смене экрана), [electron/index.html](electron/index.html) (при необходимости обёртка для прокрутки меню), [electron/css/components-buttons.css](electron/css/components-buttons.css) и/или [electron/css/layout.css](electron/css/layout.css) (сетка/расположение кнопок на экране меню, прокрутка при необходимости).

---

## 5. Настройка полей в «Список всех животных»

**Текущее состояние:**

- Экран «Список всех животных» (view) рендерится в [electron/js/view-list.js](electron/js/view-list.js) функцией `updateViewList()`. Таблица строится с фиксированным набором колонок: чекбокс, Корова, Кличка, Группа, Лактация, Дата осеменения, Бык, Попытка, Статус, Отёл, Сухостой, Примечание, Синхронизация. Нет возможности скрыть/показать колонки.

**Что сделать:**

- На экране «Список всех животных» (в шапке или рядом с панелью массовых действий) добавить кнопку **«Настройка полей»**. По умолчанию отображаются все текущие поля (поведение как сейчас).
- По нажатию открывать экран/модальное окно **«Настройка полей»**: список всех полей таблицы с чекбоксом у каждого поля (отмечено = поле отображается в таблице). Пользователь может снимать/ставить галочки и сохранять настройки. При необходимости — возможность изменить порядок полей (перетаскивание или кнопки вверх/вниз).
- Настройки видимости (и при желании порядок) сохранять в localStorage (например, ключ `cattleTracker_viewList_visibleFields` — массив id полей или объект `{ fieldKey: boolean }`). При загрузке экрана просмотра читать настройки и строить таблицу только по выбранным полям в выбранном порядке. Если сохранённых настроек нет — использовать текущий полный набор колонок по умолчанию.

**Файлы:** [electron/js/view-list.js](electron/js/view-list.js) (список полей с ключами и подписями, чтение/запись настроек, рендер таблицы по видимым полям; функция открытия/рендера экрана «Настройка полей»), [electron/index.html](electron/index.html) (контейнер или экран для «Настройка полей» и кнопка «Настройка полей» на экране view), [electron/css](electron/css) (стили для списка полей с чекбоксами при необходимости). Аналогично для веб-версии в корне (js/view-list.js, index.html).

---

## 6. Подсказки при первом запуске

**Что сделать:**

- Определить «первый запуск» (например, флаг в localStorage `cattleTracker_firstRun` или отсутствие ключа `cattleTracker_hasSeenHints`). После первого успешного открытия главного меню выставить флаг, чтобы больше не показывать подсказки.
- Показать краткий туториал или серию тултипов: например, «Объект — это база; новую базу можно добавить кнопкой «+ Добавить объект»», «Уведомления отображаются здесь» (если к этому моменту уже есть раскрывающаяся строка уведомлений), «Список всех животных — в разделе Работа с данными» и т.п. Варианты реализации: модальное окно «Добро пожаловать» с 1–3 шагами «Далее» / «Понятно», либо точечные тултипы (подсказки у конкретных элементов), закрываемые по клику или «Не показывать снова».
- Не перегружать интерфейс: 1–3 коротких сообщения достаточно.

**Файлы:** новый модуль или блок в [electron/js/app.js](electron/js/app.js) / [electron/js/menu.js](electron/js/menu.js) (логика первого запуска, показ подсказок), [electron/index.html](electron/index.html) (разметка модального окна или контейнера подсказок), [electron/css](electron/css) (стили). При необходимости — отдельный [electron/js/onboarding.js](electron/js/onboarding.js).

---

## 7. Сохранение размера и позиции окна

**Текущее состояние:**

- В [electron/main.js](electron/main.js) окно создаётся с фиксированными начальными размерами (до 900×700), позиция по центру workArea. При закрытии размер и позиция не сохраняются.

**Что сделать:**

- При закрытии окна (событие `close` или `closed`) сохранять в конфиг (например, `electron-store` или JSON-файл в userData) или через IPC в renderer — в localStorage: текущие width, height, x, y (и при желании состояние isMaximized). При следующем запуске в `createWindow()` восстанавливать размер и позицию из сохранённых данных, с проверкой, что окно не уходит за границы экрана (workArea). Если данных нет — использовать текущую логику (центр, 900×700).
- Учесть мультимонитор: сохранять display id или bounds целиком и при восстановлении проверять, что дисплей доступен.

**Файлы:** [electron/main.js](electron/main.js) (сохранение bounds при закрытии, восстановление при создании окна; при необходимости использование `electron-store` или `fs` в userData). Preload/renderer — при необходимости IPC для передачи bounds в main.

---

## 8. Дополнительные предложения (по желанию)

- **Горячие клавиши:** сочетания для перехода в «Работа с данными», «Уведомления», «Настройки».
- **Проверка обновлений по расписанию:** раз в N часов при открытом приложении, с тем же правилом «сначала спросить разрешение на скачивание».
- **Доступность:** `aria-label` и видимый фокус для кнопок меню и «Добавить объект».

---

## Порядок внедрения (рекомендуемый)

1. Исправить кнопку «Добавить объект» (п. 2).
2. Запрос разрешения на скачивание обновления (п. 3).
3. Уведомления: единый источник правды, read, раскрывающаяся строка, счётчик (п. 1).
4. Ограничение размера окна и компактная раскладка кнопок меню (п. 4).
5. Настройка полей в «Список всех животных» (п. 5).
6. Подсказки при первом запуске (п. 6).
7. Сохранение размера и позиции окна (п. 7).
8. По желанию — п. 8.

